
// include "String.aes"
contract OracleConnector =

    datatype event = QueryCreated(address, bytes(32), int, string) | OracleCreated(oracle(string, string), string)

    record state = {
        source_oracle : map(bytes(32), oracle(string, string)),
        reqc : map(address, int),
        callback_addresses : map(address, bool),
        owners: map(address, bool)
     }


    stateful entrypoint init() = { 
            source_oracle = {},
            reqc = {},
            callback_addresses = {},
            owners = {[Call.caller] = true}
         }

    payable stateful entrypoint createOracle(oracleId: bytes(32), qfee : int, rttl : int) : oracle(string, string) =
        // required a community confirmation (DAO) and fee in tokens which will be splitted to voters
        require(Map.lookup(oracleId, state.source_oracle) == None, "This type of oracle was already registered once.")
        let oracle_created : oracle(string, string) = Oracle.register(Contract.address, qfee, RelativeTTL(rttl))
        Chain.event(OracleCreated(oracle_created, "New oracle created"))
        oracle_created

    stateful entrypoint query(args: string) : bytes(32) =
         require(Address.is_contract(Call.caller), "Only a contract can call it!")
         if(Map.lookup(Call.caller, state.reqc) == None)
            put(state{reqc[Call.caller] = 0})
         put(state{reqc[Call.caller] = state.reqc[Call.caller] + 1})
         let uniq_id : bytes(32) = Crypto.sha3(String.concat(String.concat(Address.to_str(Contract.address), Address.to_str(Call.caller)), Int.to_str(state.reqc[Call.caller])))
         Chain.event(QueryCreated(Call.caller, uniq_id, Chain.timestamp, args))
         uniq_id
        
    stateful entrypoint contract_address() : address =
        Contract.address
    
    stateful entrypoint addCallBackAddress(addr: address) : bool =
        require(state.owners[Call.caller] == true, "Only owners can do this transaction")
        put(state{callback_addresses[addr] = true})
        true
    
    stateful entrypoint canCallBack() : bool =
        if(Map.lookup(Call.caller, state.callback_addresses) == None)
          abort("Only accepted address can send callback")
        state.callback_addresses[Call.caller] == true

    stateful entrypoint withdrawFunds(send_to: address, amount: int) =
        require(state.owners[Call.caller] == true, "Only owners can do this transaction")
        Chain.spend(send_to, amount)
    
    public entrypoint getCurrentContractBalance() : int =
        Contract.balance
    
    payable public stateful entrypoint acceptAssets() : int =
        //Take in funds
        Contract.balance

    
    